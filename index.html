<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>PGN Fixer</title>
  <base href="../" />
  <link rel="stylesheet" href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css" integrity="sha384-q94+BZtLrkL1/ohfjR8c6L+A6qzNH9R2hBLwyoAfu3i/WCvQjzL2RQJ3uNHDISdU" crossorigin="anonymous">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-sRIl4kxILFvY47J16cr9ZwB07vP4J8+LH7qKQnuqkuIAvNWLzeN8tE5YBujZqJLB" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/js/bootstrap.bundle.min.js" integrity="sha384-FKyoEForCGlyvwx9Hj09JcYn3nv7wiPVlz7YYwJrWVcXK/BmnVDxM+D2scQbITxI" crossorigin="anonymous"></script>
  <style>
  	body {
  	  color: black;
  	  font-family: monospace;
  	  background-color: #ebecd0;
  	  text-align: center;
  	}

  	button {
  	  color: black;
      font-family: var(--font-mono);
   	  background-color: #779556;
  	  padding: 5px 10px;
      border-radius: 3px;
      margin: 0.5rem;
  	}

  	h1 {
  		padding-top: 2rem;
  	}

    @media screen and (max-width: 600px) {
      .column {
        width: 100%;
      }
    }

	textarea {
		width: 100%;
	}
  </style>
</head>
<body>
  <div class="container">
    <h1 class="title">PGN Fixer</h1>
    <p>
      This is a tool that can be used for fixing PGNs where some moves are incorrect - e.g. because they are ambiguous Knight or Rook moves.
      Paste your PGN into the Orignal PGN box and hit Load PGN. When erroneous moves are found the tool will wait for you to play the correct move, then continue.
    </p>
    <br />
    <div>
      <div id="myBoard" class="container" style="width: 400px"></div>
      <br />
      <button onclick="loadPgn()">Load PGN</button>
    </div>
    <br />
    <div>
      <b>Erroneous/Ambiguous Move:</b>
      <p id="ambiguous"></p>
      <b>Valid Moves in this Position:</b>
      <p id="valid"></p>
      <b>Game Status:</b>
      <p id="status"></p>
    </div>
  	<div class="row">
	  <div class="col">
	    <b>Original PGN:</b>
	    <br />
	    <textarea id="pgnIn" rows="10"></textarea>
	  </div>
	  <div class="col">
	    <b>Fixed PGN:</b>
	    <br />
	    <textarea id="pgn" rows="10"></textarea>
	  </div>
    </div>
  </div>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha384-vk5WoKIaW/vJyUAd9n/wmopsmNhiy+L2Z+SBxGYnUkunIxVxAv/UtMOhba/xskxh" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js" integrity="sha384-8Vi8VHwn3vjQ9eUHUxex3JSN/NFqUg3QbPyX8kWyb93+8AC/pPWTzj+nHtbC5bxD" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.2/chess.js" integrity="sha384-s3XgLpvmHyscVpijnseAmye819Ee3yaGa8NxstkJVyA6nuDFjt59u1QvuEl/mecz" crossorigin="anonymous"></script>
  <script>
    let $ambiguous = $('#ambiguous');
    let $valid = $('#valid');
    let $status = $('#status');
    let $pgnIn = $('textarea#pgnIn');
    let $pgnOut = $('textarea#pgn');
    let lastMove = "";
    let pgnError = false;
    const game = new Chess();
    let pgn = "";
    let header = "";
    let numPly = 0;
    let tpgn = "";
    let lastOk = 0;
    let moves = [];
    let commentMap = {}; // Map ply index to comments
    let variationsMap = {}; // Map ply index to variations that start after that move
    let rawPgnWithVariations = ""; // Store original PGN with variations intact

    var config = {
      draggable: true,
      onDragStart: onDragStart,
      onDrop: onDrop,
      onSnapEnd: onSnapEnd,
      pieceTheme: 'https://chessboardjs.com/img/chesspieces/wikipedia/{piece}.png'
    }
    board = Chessboard('myBoard', config)

    function tryLoadPgn() {

      pgnError = false;
      for (let i = numPly - 1; i >= 0; i--) {
        tpgn = getPgn(moves, i);
        if (game.load_pgn(tpgn)) {
          lastOk = i;
          console.log("OK", i, moves[i]);
          break;
        } else {
          pgnError = true;
        }
      }

      updateStatus();

      console.log(tpgn);

      console.log(game.ascii());
      console.log(game.moves());

      board.position(game.fen());
    }

    function getPgn(moves, to) {
      let pgn = "";
      for (let i = 0; i <= to; i++) {
        if (i % 2 == 0) {
          pgn += " " + (1 + i / 2) + ".";
        }
        pgn += " " + moves[i];
        // Append any comments associated with this ply
        if (commentMap[i]) {
          pgn += " " + commentMap[i];
        }
      }
      return pgn;
    }

    function onDragStart(source, piece, position, orientation) {
      // do not pick up pieces if the game is over
      if (game.game_over()) return false

      // only pick up pieces for the side to move
      if ((game.turn() === 'w' && piece.search(/^b/) !== -1) ||
        (game.turn() === 'b' && piece.search(/^w/) !== -1)) {
        return false
      }
    }

    function onDrop(source, target) {
      // see if the move is legal
      var move = game.move({
        from: source,
        to: target,
        promotion: 'q' // NOTE: always promote to a queen for example simplicity
      })

      // illegal move
      if (move === null) return 'snapback'

      lastMove = move.san;
      if (pgnError) {
        moves[lastOk + 1] = lastMove;
        updateStatus();
        setTimeout(tryLoadPgn, 500);
      } else {
        updateStatus();
      }
    }

    // update the board position after the piece snap
    // for castling, en passant, pawn promotion
    function onSnapEnd() {
      board.position(game.fen())
    }

    function updateStatus() {
      var status = ''

      var moveColor = 'White'
      if (game.turn() === 'b') {
        moveColor = 'Black'
      }

      // checkmate?
      if (game.in_checkmate()) {
        status = 'Game over, ' + moveColor + ' is in checkmate.'
      }

      // draw?
      else if (game.in_draw()) {
        status = 'Game over, drawn position'
      }

      // game still on
      else {
        status = moveColor + ' to move'

        // check?
        if (game.in_check()) {
          status += ', ' + moveColor + ' is in check'
        }
      }

      $status.html(status)
      $ambiguous.html(pgnError ? moves[lastOk + 1] : "None");
      $valid.html(game.moves().length > 0 ? game.moves().join(" ") : "None");
      $pgnIn.html(pgn);
      $pgnOut.html(header + '\n' + injectCommentsAndVariationsIntoPgn(game.pgn()));
    }

    /**
     * Extract comments and variations from PGN text.
     * Stores comments by ply index and variations by their starting ply.
     * Returns the text with comments/annotations removed but keeps main line.
     */
    function extractCommentsAndVariations(pgnText) {
      commentMap = {};
      variationsMap = {};
      rawPgnWithVariations = pgnText;

      let cleanedText = pgnText;

      // First, extract and store all variations (text within parentheses)
      const variationRegex = /\(([^()]*(?:\([^()]*\)[^()]*)*)\)/g;
      let variationMatches = [];
      let match;

      while ((match = variationRegex.exec(pgnText)) !== null) {
        variationMatches.push({
          fullText: match[0],
          content: match[1],
          index: match.index
        });
      }

      // Remove variations temporarily to process main line
      cleanedText = pgnText.replace(/\([^()]*(?:\([^()]*\)[^()]*)*\)/g, '');

      // Extract comments from remaining text
      const commentRegex = /\{[^}]*\}|\$\d+/g;
      let commentMatches = [];
      while ((match = commentRegex.exec(cleanedText)) !== null) {
        commentMatches.push({
          text: match[0],
          index: match.index
        });
      }

      // Build a mapping of moves to comments by parsing main line
      let mainLineMoves = [];
      let tempText = cleanedText.replace(/^\s*\[.*?\]\s*$/gm, '').trim();
      tempText = tempText.replace(/\s*(1-0|0-1|1\/2-1\/2|\*)\s*$/,'').trim();

      const moveRegex = /(\d+\.(?:\s*\.\.\.)?\s*)?([^\s{}]+)\s*(\{[^}]*\}|\$\d+)?/g;
      let plyCount = 0;
      let lastMoveNum = 0;

      while ((match = moveRegex.exec(tempText)) !== null) {
        const moveNum = match[1];
        const move = match[2];
        const comment = match[3];

        if (!move.match(/^(1-0|0-1|1\/2-1\/2|\*)$/)) {
          if (comment) {
            commentMap[plyCount] = comment;
          }
          plyCount++;
        }
      }

      // Store variations for later reinjection
      // This is a simplified approach - a full implementation would need
      // to map variations to their exact position in the corrected game
      if (variationMatches.length > 0) {
        for (let varMatch of variationMatches) {
          variationsMap['raw'] = variationMatches;
        }
      }

      // Remove all comments and variations
      cleanedText = pgnText.replace(/\{[^}]*\}/g, '').replace(/\$\d+/g, '').replace(/\([^()]*(?:\([^()]*\)[^()]*)*\)/g, '');

      return cleanedText;
    }

    /**
     * Reinject comments and variations back into the corrected PGN.
     */
    function injectCommentsAndVariationsIntoPgn(pgnText) {
      if (Object.keys(commentMap).length === 0 && Object.keys(variationsMap).length === 0) {
        return pgnText;
      }

      let result = "";
      let plyIndex = 0;

      const lines = pgnText.split('\n');
      let outputLines = [];

      for (let line of lines) {
        // Skip header lines
        if (line.match(/^\s*\[/)) {
          outputLines.push(line);
          continue;
        }

        // Process move line
        let processedLine = line;
        const moveTokens = line.trim().split(/\s+/);
        let newTokens = [];

        for (let token of moveTokens) {
          newTokens.push(token);

          // After each move (but not move numbers or results), add its comment if it exists
          if (!/^\d+\.?$/.test(token) && !/^(1-0|0-1|1\/2-1\/2|\*)$/.test(token) && token.length > 0) {
            if (commentMap[plyIndex]) {
              newTokens.push(commentMap[plyIndex]);
            }
            plyIndex++;
          }
        }

        processedLine = newTokens.join(' ');

        // Reinject variations if they exist
        if (variationsMap['raw'] && variationsMap['raw'].length > 0) {
          // This is a basic implementation - for full variation support,
          // you would need more sophisticated parsing to match variation
          // positions to their correct locations in the corrected game
          for (let varMatch of variationsMap['raw']) {
            // Try to insert variations at appropriate points
            // This is a simplified heuristic approach
            processedLine += ' ' + varMatch.fullText;
          }
        }

        outputLines.push(processedLine);
      }

      result = outputLines.join('\n');
      return result.trim();
    }

    function loadPgn() {
      pgnError = false;
      moves = [];
      pgn = $pgnIn.val() || '';

      // Extract comments AND variations BEFORE removing them
      extractCommentsAndVariations(pgn);

      // Remove comment blocks and annotations
      pgn = pgn.replace(/\{[^}]*\}/g, '').replace(/\$\d+/g, '');

      // Remove variations (parentheses) from main processing
      pgn = pgn.replace(/\([^()]*(?:\([^()]*\)[^()]*)*\)/g, '');

      // Extract header lines (all lines that start with '[' and end with ']')
      let headerMatch = pgn.match(/^\s*\[.*?\]\s*$/gim);
      header = headerMatch ? headerMatch.join('\n') : '';

      // Remove header lines to get only the movetext
      let movetext = pgn.replace(/^\s*\[.*?\]\s*$/gim, '').trim();

      // Strip a trailing game result if present (1-0, 0-1, 1/2-1/2 or *)
      movetext = movetext.replace(/\s*(1-0|0-1|1\/2-1\/2|\*)\s*$/,'').trim();

      // Regex to match move numbers and capture up to two SAN moves (white and optional black)
      // Handles forms like "1. e4 e5" and "1... e5" (ellipsis for black-only in some notations)
      let rx = /\d+\.(?:\s*\.\.\.)?\s*([^\s]+)(?:\s+([^\s]+))?/g;
      let match;
      while ((match = rx.exec(movetext)) !== null) {
        if (match[1]) moves.push(match[1]);
        if (match[2]) moves.push(match[2]);
      }

      // Number of ply is simply the number of parsed moves
      numPly = moves.length;

      tryLoadPgn();
    }
  </script>
</body>
</html>
